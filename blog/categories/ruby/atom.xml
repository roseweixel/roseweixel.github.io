<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | code.life]]></title>
  <link href="http://roseweixel.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://roseweixel.github.io/"/>
  <updated>2014-10-23T02:15:57-04:00</updated>
  <id>http://roseweixel.github.io/</id>
  <author>
    <name><![CDATA[Rose Weixel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Join Tables in ActiveRecord: Complex Associations, Simple Code]]></title>
    <link href="http://roseweixel.github.io/blog/2014/10/22/join-tables-for-dr-who/"/>
    <updated>2014-10-22T21:38:48-04:00</updated>
    <id>http://roseweixel.github.io/blog/2014/10/22/join-tables-for-dr-who</id>
    <content type="html"><![CDATA[<p>Up until a few weeks ago, my entire coding toolbox consisted of a small sampling of some built in Ruby methods. Two of these became blog post topics (<a href="http://roseweixel.github.io/blog/2014/10/08/looking-for-something-just-number-find-it/">#find</a> and <a href="http://roseweixel.github.io/blog/2014/10/07/cheese-dot-slice/">#slice</a>), and one&ndash;the <code>&lt;&lt;</code> method&ndash;became the central character of my first coding dream/nightmare, with reserved words <code>while</code> and <code>true</code> playing key supporting roles. I used these methods to write other pretty simple methods.</p>

<p>After just a few weeks at <a href="http://www.flatironschool.com">The Flatiron School</a>, I&rsquo;m quickly learning that building up complex programs, like web apps, can&rsquo;t (or maybe really just shouldn&rsquo;t) be accomplished by writing out method after method in one big file. You need the right structures and tools to create complex objects, persist them in a database, and express relationships between these objects. Using ActiveRecord, you get some really simple and powerful tools for all this that hide a huge amount of complexity away, allowing you focus on designing your app to do what you want it to do.</p>

<p>While ActiveRecord makes it easy to create models and associations, some of the concepts involved were hard for me to get my head around at first. One such concept was the join table. I ran up against a problem in need of a join table while working with my classmates on a lab involving modeling characters and actors.</p>

<p>In ActiveRecord speak, actors have many characters and a character belongs to an actor. Here, in all of its elegant simplicity, is how you&rsquo;d create the models that express this relationship:</p>

<pre><code class="ruby app/models/actor.rb">class Actor &lt; ActiveRecord::Base
  has_many :characters
end
</code></pre>

<pre><code class="ruby app/models/character.rb">class Character &lt; ActiveRecord::Base
  belongs_to :actor
end
</code></pre>

<p>Now all we need are two tables (actors and characters) to make this association work. The characters table, being on the <code>belongs_to</code> side of the relationship, must have a column for the foreign key, <code>actor_id</code>. In ActiveRecord, this can be accomplished in remarkably few lines of code:</p>

<pre><code class="ruby db/migrations/001_create_actors.rb">class CreateActors &lt; ActiveRecord::Migration
  def change
    create_table :actors do |t|
      # ActiveRecord provides an id (primary key) column by default, for free!
      t.string :name
    end
  end
end
</code></pre>

<pre><code class="ruby db/migrations/002_create_characters.rb">class CreateCharacters &lt; ActiveRecord::Migration
  def change
    create_table :characters do |t|
      t.string :name
      # Here is where the magic happens. ActiveRecord knows that this references the actors table.
      t.integer :actor_id
    end
  end
end
</code></pre>

<p>This is the basic pattern you&rsquo;d follow to model any <code>has_many</code> <code>belongs_to</code> relationship in ActiveRecord. What seems like &ldquo;magic&rdquo; here is made possible by ActiveRecord Ruby methods that either give our associated classes more methods that let them interact with each other, or wrap SQL statements and hide them away (in the case of migrations). But that is another topic for another post.</p>

<p>Back to actors and characters. As my classmates and I were creating these models, two big things came to the surface:</p>

<p>1) We could not recall any of Tom Cruise&rsquo;s many characters&#8217; names.</p>

<p>2) What happens when a character has more than one actor? One of my favorite characters would most certainly break our has many/belongs to association - The Doctor.</p>

<p><img class="center" src="/images/sad_doc_rain.jpeg" width="500" height="500" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>How can we fit The Doctor into our current schema??? The more I thought about it, the more impossible it seemed. Here is an illustration:</p>

<p><img class="center" src="/images/actor_char_table.png" width="500" height="500" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The above is our simple model, before The Doctor comes along and breaks everything. Just to be sure I was grasping how NOT to try to include The Doctor and his many actors, here is how it might look:</p>

<p><img class="center" src="/images/the_doctor_breaks_the_model.png" width="800" height="800" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Our actors table seems fine, but our characters table is definitely not okay, and we haven&rsquo;t even included the eight doctors from the first twenty-six seasons yet.</p>

<p>With our current setup, we have to change the entire schema every time we add another Doctor. This is very, very bad. A database was designed for adding lots of rows. Not so for columns.</p>

<p>In order to make things right, we need a different association: many-to-many. Actors have many characters, and a character has many actors. Thus, we would replace <code>belongs_to :actor</code> with <code>has_many :actors</code> in <code>app/models/character.rb</code>. But how do we get our database set up for this more complicated association?  We need a join table. First the visual:</p>

<p><img class="center" src="/images/actors_characters_join.png" width="650" height="650" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Now for the migration (assuming your actors table is still intact and you&rsquo;ve already removed all but the name column from characters):</p>

<pre><code class="ruby 004_create_actors_characters_join_table.rb">class CreateActorsCharactersJoinTable &lt; ActiveRecord::Migration
  def change
    create_table :actors_characters, id: false do |t|
      # using id: false prevents the default primary key column from being created, because there's no use for it here
      t.integer :actor_id
      t.integer :character_id
    end
  end
end
</code></pre>

<p>Now we have the right associations and the right database schema to add all of the Doctors that ever were and ever will be throughout all time.</p>

<p><img class="center" src="/images/first_doctor.jpeg" width="500" height="500" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Looking for Something? Just #find It!]]></title>
    <link href="http://roseweixel.github.io/blog/2014/10/08/looking-for-something-just-number-find-it/"/>
    <updated>2014-10-08T20:32:04-04:00</updated>
    <id>http://roseweixel.github.io/blog/2014/10/08/looking-for-something-just-number-find-it</id>
    <content type="html"><![CDATA[<p>Searching through nested data structures can be downright messy. Even saying &ldquo;nested data structures&rdquo; sounds complicated. Luckily, Ruby has some powerful <a href="http://www.ruby-doc.org/core-2.1.3/Enumerable.html">Enumerable methods</a> that can simplify our lives (or at least our code).</p>

<p>Let&rsquo;s say you&rsquo;ve been programming for hours and suddenly realize your stomach is growling at you (why does this happen so often?). Here is how you might search for some delicious food, if you happened to be searching inside an array filled with hashes. Just humor me for the sake of example.</p>

<p>Here is our <code>restaurants</code> array:</p>

<pre><code class="ruby">restaurants = [
    {:name =&gt; "The Decent Diner", :rating =&gt; "average"}, 
    {:name =&gt; "The GoGo Grill", :rating =&gt; "delicious"}, 
    {:name =&gt; "Emporium of Mystery Meat", :rating =&gt; "poor"},  
    {:name =&gt; "Dig Inn Seasonal Market", :rating =&gt; "delicious"}
]
</code></pre>

<p>So, we want to get the name of a restaurant whose <code>:rating</code> is <code>"delicious"</code>. We could do something like this:</p>

<pre><code class="ruby">def find_delicious_food(restaurants)
      restaurants.each do |restaurant_info|
    restaurant_info.values.each do |value|
      if value == "delicious"
        return restaurant_info[:name]
      end
    end
  end
end
</code></pre>

<p>If we call this method on our <code>restaurants</code> hash, it will return the value &ldquo;The GoGo Grill&rdquo;. Sounds good to me. But in order to get there we needed a <code>return</code> inside an <code>if</code> statement inside an <code>each</code> loop inside another <code>each</code> loop. Not pretty.</p>

<p>There is a better way. The <code>find</code> method! Behold:</p>

<pre><code class="ruby">def find_delicious_food(restaurants)
  restaurants.find{|restaurant| restaurant[:rating] == "delicious"}[:name]
end
</code></pre>

<p>Just one line of code seems to do the same thing as its ugly predecessor. Let&rsquo;s look at it more closely. Here is what <code>find</code> does:</p>

<ul>
<li>It passes each element of the object on which it was called to a block.</li>
<li>It returns the first element for which the block evaluates to <code>true</code>.</li>
<li>If none of the elements return true for the given block, it returns <code>nil</code>.</li>
</ul>


<p>As it turns out, this <code>nil</code> value could cause some problems for our <code>find_delicious_food</code> method. If there are no restaurants in the hash with a <code>:rating</code> of <code>"delicious"</code>, our code breaks. We would get an error, because Ruby cannot make any sense out of <code>nil[:name]</code>.</p>

<p>Here is the method refactored to avoid that error:</p>

<pre><code class="ruby">def find_delicious_food(restaurants)
  good_restaurant = restaurants.find{|restaurant| restaurant[:rating] == "delicious"}
  if good_restaurant
    return good_restaurant[:name]
  end
end
</code></pre>

<p>Sure, it may not be as cute and little as our one-line method, but it will never break and it&rsquo;s still a lot prettier than loops inside loops.</p>

<p>So when you are searching for that <em>one</em> thing you need inside of some nasty nesting, just <code>find</code> it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cheese.slice]]></title>
    <link href="http://roseweixel.github.io/blog/2014/10/07/cheese-dot-slice/"/>
    <updated>2014-10-07T22:07:16-04:00</updated>
    <id>http://roseweixel.github.io/blog/2014/10/07/cheese-dot-slice</id>
    <content type="html"><![CDATA[<p>When learning a programming language as natural as Ruby, the syntax inevitably seeps into our thoughts and alters the way we conceptualize everything from the complex to the mundane. Thus, the title of this blog (and, indeed, this post).</p>

<p>It is easy for this to happen, in part because Ruby has such an extensive library of methods whose names and behaviors make them ideal for modeling real life. One such method is <code>slice</code>.</p>

<p>The method <code>slice</code> can be called on an array (or an object that acts like an array, like a string). It literally returns a &ldquo;slice&rdquo; of the object on which it is called. The original object is left intact.</p>

<pre><code>&gt; cheese = ['gouda', 'muenster', 'provolone', 'manchego', 'brie']
&gt; my_slices = cheese.slice(1, 2)
=&gt; ["muenster", "provolone"] 
&gt; cheese
=&gt; ["gouda", "muenster", "provolone", "manchego", "brie"]
</code></pre>

<p>If you need to take more drastic measures, <code>slice!</code> will modify the original object, removing (and returning) everything you sliced out.</p>

<pre><code>&gt; cheese = ['gouda', 'muenster', 'provolone', 'manchego', 'brie']
&gt; my_slices = cheese.slice!(1, 2)
=&gt; ["muenster", "provolone"] 
&gt; cheese
=&gt; ["gouda", "manchego", "brie"]
</code></pre>

<p>Here are three different ways to use <code>slice</code> (<code>slice!</code> can also be invoked in these ways, and both can be used with arrays and strings):</p>

<ul>
<li><p><code>array.slice(index)</code> returns the object at <code>array[index]</code>, or <code>nil</code> if there is no object there to return.</p></li>
<li><p><code>array.slice(start, length)</code> returns a new array containing the elements of <code>array</code> starting at <code>start</code> and continuing for <code>length</code> elements (as shown in the code examples above). If there are no objects there, it returns <code>nil</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></li>
<li><p><code>array.slice(range)</code> returns a new array containing the objects at <code>array[range]</code>, or <code>nil</code>.</p></li>
</ul>


<p>  For more on this and other Ruby Array methods, see the <a href="http://www.ruby-doc.org/core-2.1.3/Array.html#method-i-slice">documentation</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>There are some special cases that return an empty array. See the <a href="http://www.ruby-doc.org/core-2.1.3/Array.html#method-i-slice">documentation</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
