<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | code.life]]></title>
  <link href="http://roseweixel.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://roseweixel.github.io/"/>
  <updated>2015-06-14T22:17:08-04:00</updated>
  <id>http://roseweixel.github.io/</id>
  <author>
    <name><![CDATA[Rose Weixel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Live Updating DOM Elements With jQuery and Ajax]]></title>
    <link href="http://roseweixel.github.io/blog/2015/06/04/live-updating-dom-elements-with-jquery-and-ajax/"/>
    <updated>2015-06-04T21:20:11-04:00</updated>
    <id>http://roseweixel.github.io/blog/2015/06/04/live-updating-dom-elements-with-jquery-and-ajax</id>
    <content type="html"><![CDATA[<p>Any web app that involves real-time interactions between users requires some form of live notifications. Implementing this, for a beginner developer such as myself, can be a daunting challenge. This post will walk through how I went about solving this problem when working on <a href="http://www.lacquerlove.com">Lacquer Love&amp;Lend</a>, a social network for nail polish lovers that allows users to interact via friendships and lacquer loans. As with any social network, I wanted users to see live notifications whenever they received a new friendship or transaction request, or when the <code>state</code> of any of their friendships or transactions changed. The example that follows assumes some basic knowledge of Rails.</p>

<h2>Some Basic Ajax</h2>

<p>In a basic Ajax request, a user clicks on something, the Ajax request gets sent, and a part of the DOM gets updated without the entire page reloading.</p>

<p><img class="center" src="/images/basic_ajax_request.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The code usually looks something like this:</p>

<pre><code class="javascript app/assets/javascripts/something.js">// 1) Wait for the document to be ready.
$(document).ready(function() {
    // 2) Listen for the submission of the form.
    $("form").submit(function(event) {

        // 3) Prevent an entire page load (or reload).
        event.preventDefault();

        // 4) Grab the information from the form needed for the Ajax request.
        var formAction = $(this).attr('action'); // e.g. '/somethings'
        var formMethod = $(this).attr('method'); // e.g. 'post'
        var formData   = $(this).serializeArray(); // grabs the form data and makes your params nicely structured!

        // 5) Make the Ajax request, which will hit the 'create' action in the 'somethings' controller
        $.ajax({
          url:  formAction,
          type: formMethod,
          data: formData
        });
    });
});
</code></pre>

<p>For the basic example, I&rsquo;m omitting the controller and view as the main focus of this post is how I implemented live notifications. A more detailed explanation of basic Ajax will follow in my next post - a prequel to this one, if you will :).</p>

<p>With the code above, a single user&rsquo;s action of submitting the form sets off the whole chain of events. But for live notifications, more than one user is involved and the action that changes one user&rsquo;s data is hapenning on another user&rsquo;s client! Making this happen twisted my brain into a pretzel at first, but after several attempts I got the functionality I wanted. A description of these follows below.</p>

<h2>Attempt #1: Refresh a Single Div Every 3 Seconds</h2>

<p>In order to get a single part of the page to update without the entire page refreshing, I used a <code>setInterval()</code> function to make an Ajax request every 3 seconds. This would make a <code>GET</code> request to a custom route: <code>users/:id/live_notifications</code> that hit an action named <code>live_notifications</code> in the <code>UsersController</code>.</p>

<p>1) Separate the &ldquo;live notifications&rdquo; div into a partial:</p>

<p><img class="center" src="/images/live_notifications_div.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>2) Create a route and a controller action:</p>

<pre><code class="ruby config/routes.rb">get 'users/:id/live_notifications' =&gt; 'users#live_notifications'
</code></pre>

<pre><code class="ruby app/controllers/users_controller.rb">def live_notifications
  @user = User.find(params[:id])

  respond_to do |format|
    format.js
  end
end
</code></pre>

<p>3) Make the Ajax request to hit <code>users#live_notifications</code> every 3 seconds:</p>

<pre><code class="javascript app/assets/javascripts/live_notifications.js">
$(document).ready(function() {
    var currentUrl = window.location.href;

    // Given that we're at a url like 'users/:id', this saves the unique id of the user whose show page we are currently looking at
    var userID = currentUrl.substr(currentUrl.lastIndexOf('/') + 1);

    setInterval(function() {
        $.ajax({
            type: "GET",
            url: "/users/" + userID + "/live_notifications"
        });
    }, 3000); 
});
</code></pre>

<p>4) Once this Ajax request hits the controller (which is set up to handle a JavaScript response in the <code>respond_to</code> block), Rails by default will look for <code>app/views/users/live_notifications.js.erb</code> and execute the following to refresh the partial:</p>

<pre><code class="javascript app/views/users/live_notifications.js.erb">$("#live-notifications").html('&lt;%= j render "live_notifications", user: @user %&gt;');
</code></pre>

<p>This is all it took to refresh that single div every 3 seconds. However, it was far from ideal:</p>

<ul>
<li><p>Lots of refreshing for no reason (like when you&rsquo;re looking at another user&rsquo;s page and no notifications are displayed, or when nothing has changed)</p></li>
<li><p>Things that never would change are part of the div that is being refreshed (like header text, for example)</p></li>
<li><p>Last but not least, this kind of indescriminate refreshing breaks the functionality of forms&hellip;</p></li>
</ul>


<p><img class="center" src="/images/form-refreshing-problems.gif" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<h2>A Quick Fix for Form Problems</h2>

<p>Thanks to jQuery pseudo selectors, we can stop the Ajax call from being made if an input field is currently focused:</p>

<pre><code class="javascript app/assets/javascripts/live_notifications.js">$(document).ready(function() {
    ...

    setInterval(function() {
        // prevent the Ajax call from being made if the input field in the live notifications div is focused
        if (!$('#transaction_due_date').is(":focus")){
            $.ajax({
                ...
            });
        }
    }, 3000); 
});
</code></pre>

<h2>Getting More Specific</h2>

<p>The next logical step up from the &ldquo;refresh everything all the time&rdquo; strategy was to refresh the live notifications div only when looking at one&rsquo;s own show page (in other words, when the user id in the url matches the id of the current user stored in the session).</p>

<p>In order to make the <code>current_user</code> from the Rails backend available to JavaScript, I put the following in my application layout:</p>

<p>&#8220;`html app/views/layouts/application.html.erb</p>

<script type="text/javascript">
  window.currentUser = {
      id : "<%= current_user.id if current_user %>"
  }
</script>


<pre><code>
With `current_user.id` stored in an object attached to the window, making sure the Ajax call only gets made when a user is looking at his/her own profile page is simple:
</code></pre>

<p>$(document).ready(function() {
    var currentUrl = window.location.href;
    var userID = currentUrl.substr(currentUrl.lastIndexOf(&lsquo;/&rsquo;) + 1);</p>

<pre><code>if (currentUrl.endsWith('/users/' + window.currentUser.id)) {
    setInterval(function() {
        ...
    }, 3000); 
}
</code></pre>

<p>});
&#8220;`</p>

<h2>The Final Refactor: Only Refresh When things Have Changed</h2>

<p>To change only things that have changed, when they have changed, the ability to compare what&rsquo;s on the back end with what&rsquo;s on the front end is needed.</p>

<p>For this part, I needed to capture the state of all of a user&rsquo;s transactions and friendships (the two things for which there may be a notification), and hide this information on the page. I created a method in the <code>User</code> model that returns all of these states in an array, and put this into a hidden element on the page:</p>

<p><img class="center" src="/images/hidden-tracker.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Since the transactions could also have due dates, I did something similar for those.</p>

<p>The next step was to change the code in <code>app/views/users/live_notifications.js.erb</code> to check the current state of the user&rsquo;s transactions and friendships and see if the <code>#all-categories-tracker</code> is up to date:</p>

<pre><code class="javascript app/views/users/live_notifications.js.erb">var previousInteractionStates = $('#all-categories-tracker').text();
var currentInteractionStates = "&lt;%= @user.transactions_and_friendships_data_array %&gt;";

var countOrStatusChanged = previousInteractionStates !== currentInteractionStates;

var previousDueDates = $.map($(".due-date"), function(val) {
  return $(val).text()
});
var currentDueDates = "&lt;%= @user.due_date_list %&gt;";

var dueDatesChanged = currentDueDates !== previousDueDates.toString();

if (countOrStatusChanged || dueDatesChanged) {
    // UPDATE THE “MASTER TRACKER”
    $('#all-categories-tracker').html(currentInteractionStates);

    // CHECK EACH INDIVIDUAL CATEGORY AND CHANGE ONLY WHAT’S NEEDED
    &lt;% notification_categories.each do |category| %&gt;
        var currentCategory = "&lt;%= category %&gt;";

        // DEAL WITH ANY CHANGES IN COUNT OR STATE
        var currentCategoryStates  = "&lt;%= @user.states(category) %&gt;";
        var previousCategoryStates = $(".category-tracker#" + currentCategory).html();

        // if there's been a change for this category
        if (currentCategoryStates !== previousCategoryStates) {
            // Update the DOM accordingly
             …
        }

        // DEAL WITH CHANGED DUE DATES FOR TRANSACTIONS
        if (currentCategory === 'active_requested_transactions' &amp;&amp; dueDatesChanged) {
            // Update the DOM accordingly
              …
        }        
    &lt;% end %&gt;
}
</code></pre>

<p>With this final refactoring, checks are in place that stop the unnecessary refreshing that came with the first version:</p>

<p><img class="center" src="/images/live-notifications-flow.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<h2>Alternatives</h2>

<p>The method I described above for achieving live notifications is very basic Ajax polling. Every serveral seconds, a request/response cycle fires. This inevitably means lots of database querying, even if the amount of refreshing can be reduced to a minimum. In my search for ways to reduce the burden this puts on the database, here are some other techniques I&rsquo;ve found that may offer some advantages:</p>

<p>1) Long Polling</p>

<p>With this technique, a request fires and waits for a change before sending a response. Then another request can be fired.</p>

<p>2) Web Sockets</p>

<p>Very different than Ajax polling or long polling, web sockets are used for continuous communication between server and client.</p>

<p>3) Server-Sent Events</p>

<p>Unlike web sockets which allows for continuous back and forth from server to client, this technique establishes a persistent connection that allows the server to send data to the client, but not the other way around.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making Friends (With Code)]]></title>
    <link href="http://roseweixel.github.io/blog/2014/12/04/making-friends-with-code/"/>
    <updated>2014-12-04T23:01:41-05:00</updated>
    <id>http://roseweixel.github.io/blog/2014/12/04/making-friends-with-code</id>
    <content type="html"><![CDATA[<p>This post will not be about how I&rsquo;ve spent the last ten weeks at <a href="http://flatironschool.com/">The Flatiron School</a> making awesome friends while coding together, or about my process of becoming friends with code. Those are posts for another time. This one is about the kinds of friendships that are actually built with code, the kind you can persist in a database.</p>

<p>Over the course of working on my two most recent projects, I&rsquo;ve discovered that there is more than one way to make a friendship happen on the backend of a Rails app (or most likely any app). My first crack at making friendships was for a <a href="https://lacquer-love-and-lend.herokuapp.com/">nail polish sharing app</a> where friends can view each other&rsquo;s collections and ask to borrow from each other. I watched Treehouse&rsquo;s tutorial on <a href="http://teamtreehouse.com/library/building-social-features-in-ruby-on-rails">building social features in Ruby on Rails</a>, which is a good place to start if you&rsquo;ve never done something like this before. Although it helped me understand it somewhat, the way it was done in the tutorial still seemed pretty complicated to me. I decided to try to figure it out on my own so that I could break it down and understand it better.</p>

<p>Here are the basic back-end requirements for creating a friendship (clearly some buttons and forms on the front-end are needed, but those are implementation details, so I&rsquo;ll leave them out of this post):</p>

<ul>
<li><p>You have to teach your models that some Users have relationships with other Users (a self-referential association).</p></li>
<li><p>You have to store that relationship in the database so that both sides of the relationship have knowledge of it and access to it.</p></li>
<li><p>You have to have a way of representing and keeping track of the state of the relationship at any given time (requested, accepted, etc.)</p></li>
</ul>


<p>Here&rsquo;s how I did it in my first go-around:</p>

<p>1) I created a join table, <code>friendships</code>:</p>

<pre><code class="ruby">class CreateFriendships &lt; ActiveRecord::Migration
  def change
    create_table :friendships do |t|
      t.integer :user_id
      t.integer :friend_id
      t.timestamps
    end
    # it's a good idea to add an index for faster look-ups in the database
    add_index :friendships, [:user_id, :friend_id]
  end
end
</code></pre>

<p>2) In the model for Friendship, I taught it that Friends are really just other Users:</p>

<pre><code class="ruby">class Friendship &lt; ActiveRecord::Base
  belongs_to :user
  belongs_to :friend, class_name: 'User', foreign_key: 'friend_id'

  validate :is_not_duplicate, :on =&gt; :create

  def is_not_duplicate
    if !(Friendship.where(:friend_id =&gt; friend_id, :user_id =&gt; user_id).empty? &amp;&amp; Friendship.where(:user_id =&gt; friend_id, :friend_id =&gt; user_id).empty?)
      errors.add(:friendship, "This friendship already exists!")
    end
  end
end
</code></pre>

<p>As you can see from the above, I decided I didn&rsquo;t want to allow &ldquo;duplicates&rdquo; of friendships in the database, but as it turns out there are reasons why you might not want to do it this way. I&rsquo;ll go into that later.</p>

<p>3) I made the User model aware of the Friendship model:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
  has_many :friendships
  has_many :friends, through: :friendships

  validates :name, presence: true, uniqueness: true

  def accepted_friends
    accepted_friends = []
    Friendship.where(user_id: self.id, state: 'accepted').each do |friendship|
      accepted_friends &lt;&lt; User.find(friendship.friend_id)
    end
    Friendship.where(friend_id: self.id, state: 'accepted').each do |friendship|
      accepted_friends &lt;&lt; User.find(friendship.user_id)
    end
    accepted_friends
  end

  def requested_friends_awaiting_approval
    pending_friends = []
    Friendship.where(user_id: self.id, state: 'pending').each do |friendship|
      pending_friends &lt;&lt; User.find(friendship.friend_id)
    end
    pending_friends
  end

  def friendships_for_your_approval
    pending_friendships = []
    Friendship.where(friend_id: self.id, state: 'pending').each do |friendship|
      pending_friendships &lt;&lt; friendship
    end
    pending_friendships
  end

  def friends_for_your_approval
    pending_friends = []
    Friendship.where(friend_id: self.id, state: 'pending').each do |friendship|
      friend = User.find(friendship.user_id)
      pending_friends &lt;&lt; friend
    end
    pending_friends
  end

  def all_friends
    accepted_friends + requested_friends_awaiting_approval + friends_for_your_approval
  end

end
</code></pre>

<p>You&rsquo;ll notice that I wrote a whole bunch of methods to tell Users how to find their friends on both sides of the relationship. I wanted to give users custom notifications in the views depending on whether they had a pending request or a request awaiting their approval, which was part of the reason for this. But even if I hadn&rsquo;t wanted to do that, I would have at least needed some kind of setup like this that makes multiple hits to the database every time someone wants to see all of their friends.</p>

<p>4) Finally, <code>state</code> is a big part of this model. I set it up so a friendship could have a state of <code>pending</code> or <code>accepted</code> (similar methods would create other states, like <code>rejected</code>). This is where the friendships controller comes in. For the sake of brevity, I&rsquo;ll just describe the <code>create</code> and <code>update</code> methods:</p>

<pre><code class="ruby">class FriendshipsController &lt; ApplicationController

  def create
    @user = current_user
    if params[:friendship] &amp;&amp; params[:friendship].has_key?(:friend_id)
      @friend = User.find(params[:friendship][:friend_id])
      @friendship = Friendship.new(friend: @friend, user: @user, state: 'pending')
      @friendship.save
      flash[:notice] = "Your friendship with #{@friend.name} is pending."
      redirect_to(:back)
    else
      flash[:notice] = "Friend required"
      redirect_to root_path
    end
  end

  def update
    @friendship = Friendship.find(params[:id])
    @friendship.update(state: params[:state])
    redirect_to(:back)
  end

end
</code></pre>

<p>Since I&rsquo;ve made a column in the friendships table for <code>state</code>, I can set and update the value of that attribute so a Friendship can introspect on the state it is currently in (what if we could write a method for doing this in real life?).</p>

<p>I set the <code>state</code> of the friendship to <code>'pending'</code> whenever it first gets created. Then, when the User who was &ldquo;friended&rdquo; decides to hit the &lsquo;Accept&rsquo; button (or the &lsquo;Reject&rsquo; button as the case may be), the friendship can get updated accordingly.</p>

<p>So, although the implementation of friendships I ended up with in my first attempt has the functionality I wanted, but as I mentioned before, it&rsquo;s not the most efficient. While my reasoning was that it is not desirable to have two rows in the friendships join table for every relationship that gets created, this reasoning did not take into account the way databases work. Because I have to query twice (Who are the people I&rsquo;ve friended? Who are the people who have friended me?) every single time I want to access my friends, this is actually unneccesarily expensive. Since rows in a database are cheap, why worry about adding an extra row if it reduces the number of times you need to hit the database?</p>

<p>I got a second crack at this problem during my current project, an app for teachers that includes functionality for generating seating charts according to who works well together and who doesn&rsquo;t. Along with my teammates, we built Buddyships (and Enemyships, too!) in a more reciprocal way:</p>

<pre><code class="ruby">class Enemyship &lt; ActiveRecord::Base
  belongs_to :student
  belongs_to :enemy, class_name: 'Student', foreign_key: 'enemy_id'
  belongs_to :course_section

  after_create :inversify
  after_destroy :destroy_inverse

  validates_uniqueness_of :student, :scope =&gt; [:enemy, :course_section_id]
  validates_uniqueness_of :enemy, :scope =&gt; [:student, :course_section_id]

  validate :cant_be_own_enemy, :cant_be_buddies_and_enemies

  def inversify
    self.enemy.enemyships.create(:course_section_id =&gt; self.course_section_id, :enemy_id =&gt; self.student.id)
  end

  def destroy_inverse
    if inverse = self.enemy.enemyships.where(:enemy_id =&gt; self.student.id, :course_section_id =&gt; self.course_section_id).first
      inverse.destroy
    end
  end

  private
  def cant_be_own_enemy
    if student_id == enemy_id
      errors.add(:enemy_id, "you can't be your own enemy! :(")
    end
  end

  def cant_be_buddies_and_enemies
    if Buddyship.find_by(student_id: student_id, buddy_id: enemy_id, course_section_id: course_section_id)
      errors.add(:enemy_id, "you can't be both buddies and enemies for the same class! :(")
    end
  end

end
</code></pre>

<p>In this implementation, two rows in the join table are created for each relationship, using a method aptly called <code>inversify</code>.</p>

<p>Because of the reciprocal nature of the relationship created in this model, one database query (<code>student.enemyships</code>) is all it takes to find all potential Enemies. If you were only creating relationships, you&rsquo;d care about not writing to the database more than you needed to. But since, in general, we query for friendships way more frequently than we create them, we want to make sure the querying is as efficient as possible.</p>

<p>So, while one-way relationships are fine for a follower-followee type of relationship, if you want to create a reciprocal relationship in your next app, don&rsquo;t shy away from those extra rows in the database.</p>
]]></content>
  </entry>
  
</feed>
