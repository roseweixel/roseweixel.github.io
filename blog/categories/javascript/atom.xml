<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | code.life]]></title>
  <link href="http://roseweixel.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://roseweixel.github.io/"/>
  <updated>2015-08-06T22:42:24-04:00</updated>
  <id>http://roseweixel.github.io/</id>
  <author>
    <name><![CDATA[Rose Weixel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Integrating Ajax and Rails: A Simple Todo List App]]></title>
    <link href="http://roseweixel.github.io/blog/2015/07/05/integrating-ajax-and-rails-a-simple-todo-list-app/"/>
    <updated>2015-07-05T16:59:51-04:00</updated>
    <id>http://roseweixel.github.io/blog/2015/07/05/integrating-ajax-and-rails-a-simple-todo-list-app</id>
    <content type="html"><![CDATA[<p>This post is based on a tutorial I created to teach students at <a href="http://www.flatironschool.com">The Flatiron School</a> the basics of integrating Ajax with Rails. This guide is appropriate for beginners who have already learned the basics of Rails and jQuery.</p>

<p>It will walk you through the process of adding Ajax to a very simple rails app for creating todo lists. First we&rsquo;ll go through the basics of setting up the Rails app, then adding jQuery and Ajax to add items without reloading the page. Finally, we&rsquo;ll refactor with <code>remote: true</code>. Feel free to code along!</p>

<h2>The Basic Rails Todo App</h2>

<p>Before getting to Ajax, here are the steps to create the basic rails todo app we&rsquo;ll be building on:</p>

<p>1) <code>rails new todo_app</code></p>

<p>2) <code>rails g resource todo</code></p>

<p>3) In the migration file (located in <code>db/migrate</code>):</p>

<pre><code class="ruby">class CreateTodos &lt; ActiveRecord::Migration
  def change
    create_table :todos do |t|
      t.string :description
      t.string :priority
      t.timestamps null: false
    end
  end
end
</code></pre>

<p>4) In <code>app/controllers/todos_controller.rb</code>:</p>

<pre><code class="ruby">class TodosController &lt; ApplicationController
  def index
    @todos = Todo.all
  end

  def create
    Todo.create(todo_params)
    redirect_to root_path
  end

  def destroy
    todo = Todo.find(params[:id])
    todo.destroy
    redirect_to root_path
  end

  private
    def todo_params
      params.require(:todo).permit(:description, :priority)
    end
end
</code></pre>

<p>5) In <code>config/routes.rb</code>:</p>

<pre><code class="ruby">Rails.application.routes.draw do
  root 'todos#index'
  resources :todos
end
</code></pre>

<p>6) Create <code>views/todos/index.html.erb</code> with a basic form and list of todos:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h1&gt;</span>My Todos<span class="nt">&lt;/h1&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span><span class="ni">&amp;lt;</span>%= form_for Todo.new do |f| %&gt;
</span><span class='line'>  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;form-group&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>%= f.text_field :description, placeholder:
</span><span class='line'>    <span class="ni">&amp;ldquo;</span>what needs doing?<span class="ni">&amp;rdquo;</span> %&gt;
</span><span class='line'>  <span class="nt">&lt;/div&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;form-group&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>%= f.text_field :priority, placeholder: <span class="ni">&amp;ldquo;</span>priority level<span class="ni">&amp;rdquo;</span> %&gt;
</span><span class='line'>  <span class="nt">&lt;/div&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;form-group&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="ni">&amp;lt;</span>%= f.submit %&gt;
</span><span class='line'>  <span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>% end %&gt;<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;ul&gt;</span>
</span><span class='line'><span class="err">&lt;</span>% @todos.each do |todo| %&gt;
</span><span class='line'>  <span class="nt">&lt;li&gt;</span>
</span><span class='line'>    <span class="err">&lt;</span>%= todo.description %&gt;<span class="nt">&lt;br&gt;</span>
</span><span class='line'>    <span class="nt">&lt;strong&gt;</span>priority: <span class="nt">&lt;/strong&gt;</span><span class="err">&lt;</span>%= todo.priority %&gt;<span class="nt">&lt;br&gt;</span>
</span><span class='line'>    <span class="err">&lt;</span>%= link_to &quot;done&quot;, todo_path(todo), method: &#39;delete&#39; %&gt;
</span><span class='line'>  <span class="nt">&lt;/li&gt;</span>
</span><span class='line'><span class="err">&lt;</span>% end %&gt;
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>7) Before starting up the rails server: <code>rake db:migrate</code></p>

<p>Now we can create new todos and destroy them. This is as functional as our app needs to be. Except for one thing. Since this is a single page app, it would be really nice if we could add and remove todos without reloading the page. Enter Ajax!</p>

<h2>Posting New Todos with Ajax</h2>

<p>Now we are going to &ldquo;ajaxify&rdquo; the process of creating todos. Since we are entering JavaScript land, we&rsquo;ll go into <code>app/assets/javascripts</code>. You&rsquo;ll see a file called <code>todos.coffee</code> or <code>todos.js.coffee</code>. We will not be using CoffeeScript, so rename it to <code>todos.js</code>.</p>

<p>Here&rsquo;s what we are going to implement:</p>

<p>When the &ldquo;Create Todo&rdquo; button is clicked, we will stop the default form submission behavior from happening, and send an Ajax request instead. To break this down further, here are the steps we&rsquo;ll need to follow:</p>

<ol>
<li>Create an event listener for the &lsquo;click&rsquo; event (or for the submission of the form) that loads when the document is ready and prevents the default behavior from happening (stops the page from reloading).</li>
<li>Grab some information from the form to use in our Ajax request.</li>
<li>Make the Ajax request.</li>
<li>Handle the response and add the new todo to the page.</li>
</ol>


<h3>Create an Event Listener</h3>

<p>In <code>app/assets/javascripts/todos.js</code>:</p>

<p>1) Make sure the document is ready before doing anything else.</p>

<pre><code class="javascript">// This is shorthand for $( document ).ready(function() { })
$(function(){

});
</code></pre>

<p>2) Listen for the submission of the form.</p>

<pre><code class="javascript">$(function(){
  $("form").submit(function(){
    // this debugger should be hit when you click the submit button!
    debugger;
  });
});
</code></pre>

<p>3) Prevent the default behavior (the form submitting and the page reloading).</p>

<pre><code class="javascript">$(function(){
  $("form").submit(function(event){
    event.preventDefault();

    // this debugger should be hit when you click the submit button!
    debugger;
  });
});
</code></pre>

<h3>Grab Information From the Form</h3>

<p>In order to make the Ajax request, we&rsquo;ll need to give the request the correct action and method to take us to the create action in the todos controller. If we <code>rake routes</code>, we&rsquo;ll see this:</p>

<p><code>POST   /todos(.:format)          todos#create</code></p>

<p>So we know we will be making a &lsquo;post&rsquo; request to &lsquo;/todos&rsquo;. We could hard code this in our Ajax request, but what if our routes change later on? Our request would no longer work. In order to make our code more robust, we&rsquo;ll get the correct action and method directly from the form itself. Basicaly, we&rsquo;ll ask the form where it was going by extracting the information with jQuery.</p>

<p>The <code>debugger</code> we threw into our code above will be really useful in figuring out the jQuery code for pulling out the information we need. With your server running and your JavaScript console open, fill in the form and hit the submit button. When the debugger gets hit, what is <code>this</code>?</p>

<p><img src="/images/js-console-1.png" alt="`this` in the console" /></p>

<p>Since our debugger is inside the function that&rsquo;s attached to the form submission, <code>this</code> is the form itself, and the action and method we need are right there! Let&rsquo;s use jQuery to grab them, using the handy <a href="https://api.jquery.com/attr/">.attr()</a> method.</p>

<p><img src="/images/js-console-2.png" alt="`.attr()` in the console" /></p>

<pre><code class="javascript">$(function(){
  $("form").submit(function(event){
    event.preventDefault();

    var action = $(this).attr('action');
    var method = $(this).attr('method');

  });
});
</code></pre>

<p>Of course, we also need the text we entered into the form for the todo description and priority level. If we open up the form element and all the divs that live inside of it in our console, we see that Rails gave our inputs some nice ids that we can use to select them with. Specifically, there&rsquo;s an input with an id of &ldquo;todo_description&rdquo; and an input with an id of &ldquo;todo_priority&rdquo;. Lets grab these using the jQuery <a href="https://api.jquery.com/find/">.find()</a> method.</p>

<p><img src="/images/js-console-3.png" alt=".find() in the console" /></p>

<p>We don&rsquo;t see the values that we typed into the form yet, but we can pull them out using the jQuery <a href="https://api.jquery.com/val/">.val()</a> method.</p>

<p><img src="/images/js-console-4.png" alt=".val() in the console" /></p>

<p>Great! Let&rsquo;s store these values as variables so we can pass them in to our Ajax request.</p>

<pre><code class="javascript">$(function(){
  $("form").submit(function(event){
    event.preventDefault();

    var action = $(this).attr('action');
    var method = $(this).attr('method');

    var description = $(this).find('#todo_description').val();
    var priority = $(this).find('#todo_priority').val();

  });
});
</code></pre>

<p>We are ready for the next step!</p>

<h3>Make the Ajax Request</h3>

<p>We are going to make an Ajax request that will deliver a JavaScript response to the create action in the todos controller.</p>

<p>The <a href="http://api.jquery.com/jquery.ajax/">jQuery documentation for writing Ajax requests</a> is really nice, so here&rsquo;s some code I pulled from there:</p>

<pre><code class="javascript">$.ajax({
  method: "POST",
  url: "some.php",
  data: { name: "John", location: "Boston" }
});
</code></pre>

<p>If we change the method, url, and data to the variables we created, we should be good to go! Our todos.js should now look like this:</p>

<pre><code class="javascript">$(function(){
  $("form").submit(function(event){
    event.preventDefault();

    var action = $(this).attr('action');
    var method = $(this).attr('method');

    var description = $(this).find('#todo_description').val();
    var priority = $(this).find('#todo_priority').val();

    $.ajax({
      method: method,
      url: action,
      data: { description: description, priority: priority }
    });

  });
});
</code></pre>

<p>Since we&rsquo;re expecting this Ajax request to hit the create action in the todos controller, let&rsquo;s put a <code>binding.pry</code> in there (make sure you&rsquo;ve added <code>gem 'pry'</code> to your Gemfile and run bundle install first):</p>

<pre><code class="ruby">def create
  # if our ajax request works, we'll hit this binding at take a look at params!
  binding.pry
  Todo.create(todo_params)
  redirect_to root_path
end
</code></pre>

<p>Here&rsquo;s what you&rsquo;ll see when that binding gets hit:</p>

<p><img src="/images/pry-1.png" alt="params in pry" /></p>

<p>Success! The Ajax request went where we wanted it to go and it sent the params through the way we told it to. But params is not quite right. Since we&rsquo;re using strong params, we need a nested structure where &ldquo;todo&rdquo; is a top level key. By changing our Ajax request to include <code>data: { todo: {description: description, priority: priority} }</code> this problem is solved, but there&rsquo;s actually a jQuery method, <a href="https://api.jquery.com/serializeArray/">.serializeArray()</a>, that will take care of turning all our form data into a nicely structured object (nesting included!) that we can use in our Ajax call. Here&rsquo;s how it looks in our code:</p>

<pre><code class="javascript">// .serializeArray() can be called on any form element (and here, $(this) is our form)
var data = $(this).serializeArray();

$.ajax({
  method: method,
  url: action,
  data: data
});
</code></pre>

<p>Now our params will be structured the way Rails expects them to be, and we can move on to the next step!</p>

<h3>Handle the Response</h3>

<p>We&rsquo;re still in the todos controller create action, and we&rsquo;re now able to instantiate new todos using the nicely structured params that we sent via Ajax. Currently, after creating the new Todo, we are just redirecting to the root_path. But the whole point of using Ajax is <em>not</em> to redirect. By default, a rails controller action handles responses that are sent in as html strings. We now want to tell it to respond to JavaScript:</p>

<pre><code class="ruby">def create
  Todo.create(todo_params)

  respond_to do |format|
    # if the response fomat is html, redirect as usual
    format.html { redirect_to root_path }

    # if the response format is javascript, do something else...
    format.js { }
  end
end
</code></pre>

<p>Before going further into what Rails will do with this JavaScript response, there&rsquo;s one more problem with our Ajax request. We did not tell it to send back JavaScript! Let&rsquo;s do that now, and our Ajax call should look like this:</p>

<pre><code class="javascript">$.ajax({
  method: method,
  url: action,
  data: data,

  // this line makes the response format JavaScript and not html.
  dataType: 'script'
});
</code></pre>

<p>So now that we&rsquo;re getting the response we want, what is <code>format.js { }</code> actually doing?</p>

<p>When Rails sees that line of code, it will automatically look for a file with the path <code>app/views/&lt;controller name&gt;/&lt;action name&gt;.js.erb</code>. In our example, it&rsquo;s looking for app/views/todos/create.js.erb.</p>

<p>Make that file and throw a debugger in there to confirm that it&rsquo;s actually where we land when we get out of the create action.</p>

<p><img src="/images/create-js-erb-1.png" alt="new create.js.erb file" />
<img src="/images/js-console-5.png" alt="debugger in create.js.erb" /></p>

<p>That worked! So now that we are in create.js.erb, we have access to any instance variables we created in the controller action that led us there, and we can write JavaScript and ERB (embedded Ruby) code to do whatever we want with our view. We should probably save our newly created todo in an instance variable for just that purpose.</p>

<pre><code class="ruby">def create
  @todo = Todo.create(todo_params)

  respond_to do |format|
    format.html { redirect_to root_path }
    format.js { }
  end
end
</code></pre>

<p>So what do we want to do next? In create.js.erb, we want to use JavaScript (or jQuery) to append the new todo to the <code>&lt;ul&gt;</code> where the todos live on the page.</p>

<p>We could do something like this:</p>

<pre><code class="javascript">var html = "&lt;li&gt;&lt;%= @todo.description %&gt;&lt;br&gt;&lt;strong&gt;priority: &lt;/strong&gt; &lt;%= @todo.priority %&gt;&lt;br&gt;&lt;%= escape_javascript link_to 'done', todo_path(@todo), method: 'delete' %&gt;&lt;/li&gt;";

$('ul').append(html);
</code></pre>

<p>Now, when we enter a new todo description and priority and hit the submit button, it appears on the page and no reloading happens! That&rsquo;s great, but it could use some refactoring.</p>

<ol>
<li>It&rsquo;s not DRY: we basically copied and pasted code from our index.html.erb. If the way we want to render todos ever changes, we now have to change it in two places.</li>
<li>It&rsquo;s ugly. That html string is pretty hard to read, and what&rsquo;s that <code>escape_javascript</code> doing in there? We need that or the <code>link_to</code> will be evaluated as JavaScript and the whole thing breaks.</li>
</ol>


<p>The solution to this? A partial. Extract the code for displaying a single todo out of index.html.erb and place it in  a new file at <code>app/views/todos/_todo.html.erb</code>:</p>

<p><img src="/images/todo-partial.png" alt="todo partial" /></p>

<p>Now you can use Rails magic to render the <code>@todos</code> collection in index.html.erb:</p>

<p><img src="/images/index-with-render-collection.png" alt="index using todo partial" /></p>

<p>Finally, replace the html string we had in create.js.erb with code for rendering the partial, passing in <code>@todo</code> as a local variable:</p>

<p><img src="/images/create-js-erb-2.png" alt="create.js.erb using partial" /></p>

<p>And we&rsquo;re done creating todos with Ajax! In the next section, we&rsquo;ll refactor our code by using <code>remote: true</code>.</p>

<h2>Refactoring with <code>remote: true</code></h2>

<p>In Rails, both <code>form_for</code> and <code>link_to</code> helpers can take an argument of <code>remote: true</code>:</p>

<h3>Example: <code>link_to</code> with <code>remote: true</code></h3>

<pre><code class="ruby">&lt;%= link_to 'Show Something', something_path(@something), remote: true %&gt;
</code></pre>

<p>In the case of our todo list app, we will add <code>remote: true</code> to our form for creating a new todo (the only change here is on the first line of the form):</p>

<pre><code class="ruby">&lt;%= form_for Todo.new, remote: true do |f| %&gt;
  &lt;div class="form-group"&gt;
    &lt;%= f.text_field :description, placeholder: 
    "what needs doing?" %&gt;
  &lt;/div&gt;

  &lt;div class="form-group"&gt;
    &lt;%= f.text_field :priority, placeholder: "priority level" %&gt;
  &lt;/div&gt;

  &lt;div class="form-group"&gt;
  &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>

<p>So, what does <code>remote: true</code> do for you? In short, it adds a <code>data-remote="true"</code> attribute to the generated html form as seen <a href="http://guides.rubyonrails.org/working_with_javascript_in_rails.html#form-for">here</a>, and submits the form via Ajax automagically. As with everything in Rails, there&rsquo;s metaprogramming going on under the hood. In this case, the JavaScript code that we wrote to hijack the submit event and make the appropriate Ajax request is all generated for you behind the scenes. If you&rsquo;re feeling extra curious, check out the <a href="https://github.com/rails/jquery-ujs/blob/148571ded762f22ccca84db38d4b4d56853ab395/src/rails.js">Rails.js source code</a>.</p>

<p>Here&rsquo;s a small snippet from the source code linked to above. Not so surprisingly, it looks a lot like the code we wrote (especially lines 2-4!):</p>

<pre><code class="javascript">if (element.is('form')) {
  method = element.attr('method');
  url = element.attr('action');
  data = element.serializeArray();
  // memoized value from clicked submit button
  var button = element.data('ujs:submit-button');
  if (button) {
    data.push(button);
    element.data('ujs:submit-button', null);
  }
}
</code></pre>

<p>Because Rails is providing all of this JavaScript for us, now that we&rsquo;ve added <code>remote: true</code> to the form, we can get rid of everything in our todos.js file.</p>

<h3>Before adding <code>remote: true</code>:</h3>

<pre><code class="javascript">// app/assets/javascripts/todos.js

$(function(){
  $("form").submit(function(event){
    event.preventDefault();

    var action = $(this).attr('action');
    var method = $(this).attr('method');
    var data = $(this).serializeArray();

    $.ajax({
      method: method,
      url: action,
      data: data,
      dataType: 'script'
    });

  });
});
</code></pre>

<h3>After adding <code>remote: true</code>:</h3>

<pre><code class="javascript">// app/assets/javascripts/todos.js
</code></pre>

<p>Just like when we manually wrote out the Ajax call, when the form is submitted the default behavior will be prevented and a JavaScript response will be sent to the create action in the todos controller. The controller will then send us to app/views/todos/create.js.erb, just as it did before. We will leave the rest of our code as is, and we are done with our refactoring!</p>

<h2>Deleting todos with <code>remote: true</code></h2>

<p>Now that we&rsquo;ve seen the beautiful simplicity of <code>remote: true</code>, let&rsquo;s see how quick and easy it is to remove todos from the database and the DOM with no refreshing needed:</p>

<p>1) In <code>views/todos/index.html.erb</code>, we have a link that hits the <code>destroy</code> action in the <code>TodosController</code>. Simply add <code>remote: true</code> to it.</p>

<p><strong>Note: At this point it&rsquo;s also important to give each <code>&lt;li&gt;</code> an <code>id</code> that will help us remove the correct item from the DOM after deleting it.</strong></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h1&gt;</span>My Todos<span class="nt">&lt;/h1&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span><span class="ni">&amp;hellip;</span><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;ul&gt;</span>
</span><span class='line'><span class="err">&lt;</span>% @todos.each do |todo| %&gt;
</span><span class='line'>  <span class="c">&lt;!-- This `id` attribute will help us find the correct element to remove using jQuery --&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li</span> <span class="na">id=</span><span class="s">&quot;&lt;%= todo.id %&gt;&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="err">&lt;</span>%= todo.description %&gt;<span class="nt">&lt;br&gt;</span>
</span><span class='line'>    <span class="nt">&lt;strong&gt;</span>priority: <span class="nt">&lt;/strong&gt;</span><span class="err">&lt;</span>%= todo.priority %&gt;<span class="nt">&lt;br&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c">&lt;!-- Add `remote: true` to the line below --&gt;</span>
</span><span class='line'>    <span class="err">&lt;</span>%= link_to &quot;done&quot;, todo_path(todo), method: &#39;delete&#39;, remote: true %&gt;
</span><span class='line'>  <span class="nt">&lt;/li&gt;</span>
</span><span class='line'><span class="err">&lt;</span>% end %&gt;
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>2) Tell the <code>todos#destroy</code> action how to <code>respond_to</code> a JavaScript response:</p>

<pre><code class="ruby">def destroy
  # we need an instance variable `@todo` so we can access it in the next step!
  @todo = Todo.find(params[:id])
  @todo.destroy

  respond_to do |format|
    format.html { redirect_to root_path }
    format.js { }
  end
end
</code></pre>

<p>3) Remember that line 7 in the <code>destroy</code> action above will trigger Rails to look for <code>app/views/todos/destroy.js.erb</code>, so create that file and add code to select the todo to remove using jQuery. Let&rsquo;s make it <code>slideUp()</code>:</p>

<pre><code class="javascript">$("li#&lt;%= @todo.id %&gt;").slideUp();
</code></pre>

<p>And that&rsquo;s it. With this simple yet powerful pattern, you can easily ajaxify all the things in all of your Rails apps. If you&rsquo;re interested in learning more, I&rsquo;ve listed some handy resources below. Happy coding!</p>

<p><img class="center" src="/images/ajaxify-all-the-things.jpg" width="400" height="400" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<h2>Additional Resources</h2>

<ul>
<li><a href="http://api.jquery.com/jquery.ajax/">jQuery Documentation - jQuery.ajax()</a></li>
<li><a href="http://blog.flatironschool.com/post/56146220219/learning-about-ajax">Learning About Ajax</a></li>
<li><a href="http://guides.rubyonrails.org/working_with_javascript_in_rails.html">Rails Documentation - Working with JavaScript in Rails</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Live Updating DOM Elements With jQuery and Ajax]]></title>
    <link href="http://roseweixel.github.io/blog/2015/06/04/live-updating-dom-elements-with-jquery-and-ajax/"/>
    <updated>2015-06-04T21:20:11-04:00</updated>
    <id>http://roseweixel.github.io/blog/2015/06/04/live-updating-dom-elements-with-jquery-and-ajax</id>
    <content type="html"><![CDATA[<p><em><strong>Based on a <a href="/presentations">talk I gave</a> at the <a href="http://www.meetup.com/nychtml5/events/222437348/">NYCHTML5 Meetup</a> on June 2nd, 2015.</strong></em></p>

<p>Any web app that involves real-time interactions between users requires some form of live notifications. Implementing this, for a beginner developer such as myself, can be a daunting challenge. This post will walk through how I went about solving this problem when working on <a href="http://www.lacquerlove.com">Lacquer Love&amp;Lend</a>, a social network for nail polish lovers that allows users to interact via friendships and lacquer loans. As with any social network, I wanted users to see live notifications whenever they received a new friendship or transaction request, or when the <code>state</code> of any of their friendships or transactions changed. The example that follows assumes some basic knowledge of Rails.</p>

<h2>Some Basic Ajax</h2>

<p>In a basic Ajax request, a user clicks on something, the Ajax request gets sent, and a part of the DOM gets updated without the entire page reloading.</p>

<p><img class="center" src="/images/basic_ajax_request.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The code usually looks something like this:</p>

<pre><code class="javascript app/assets/javascripts/something.js">// 1) Wait for the document to be ready.
$(document).ready(function() {
    // 2) Listen for the submission of the form.
    $("form").submit(function(event) {

        // 3) Prevent an entire page load (or reload).
        event.preventDefault();

        // 4) Grab the information from the form needed for the Ajax request.
        var formAction = $(this).attr('action'); // e.g. '/somethings'
        var formMethod = $(this).attr('method'); // e.g. 'post'
        var formData   = $(this).serializeArray(); // grabs the form data and makes your params nicely structured!

        // 5) Make the Ajax request, which will hit the 'create' action in the 'somethings' controller
        $.ajax({
          url:  formAction,
          type: formMethod,
          data: formData
        });
    });
});
</code></pre>

<p>For the basic example, I&rsquo;m omitting the controller and view as the main focus of this post is how I implemented live notifications. A more detailed explanation of basic Ajax follows <a href="http://roseweixel.github.io/blog/2015/07/05/integrating-ajax-and-rails-a-simple-todo-list-app/">in my next post</a> - a prequel to this one, if you will :).</p>

<p>With the code above, a single user&rsquo;s action of submitting the form sets off the whole chain of events. But for live notifications, more than one user is involved and the action that changes one user&rsquo;s data is hapenning on another user&rsquo;s client! Making this happen twisted my brain into a pretzel at first, but after several attempts I got the functionality I wanted. A description of these follows below.</p>

<h2>Attempt #1: Refresh a Single Div Every 3 Seconds</h2>

<p>In order to get a single part of the page to update without the entire page refreshing, I used a <code>setInterval()</code> function to make an Ajax request every 3 seconds. This would make a <code>GET</code> request to a custom route: <code>users/:id/live_notifications</code> that hit an action named <code>live_notifications</code> in the <code>UsersController</code>.</p>

<p>1) Separate the &ldquo;live notifications&rdquo; div into a partial:</p>

<p><img class="center" src="/images/live_notifications_div.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>2) Create a route and a controller action:</p>

<pre><code class="ruby config/routes.rb">get 'users/:id/live_notifications' =&gt; 'users#live_notifications'
</code></pre>

<pre><code class="ruby app/controllers/users_controller.rb">def live_notifications
  @user = User.find(params[:id])

  respond_to do |format|
    format.js
  end
end
</code></pre>

<p>3) Make the Ajax request to hit <code>users#live_notifications</code> every 3 seconds:</p>

<pre><code class="javascript app/assets/javascripts/live_notifications.js">
$(document).ready(function() {
    var currentUrl = window.location.href;

    // Given that we're at a url like 'users/:id', this saves the unique id of the user whose show page we are currently looking at
    var userID = currentUrl.substr(currentUrl.lastIndexOf('/') + 1);

    setInterval(function() {
        $.ajax({
            type: "GET",
            url: "/users/" + userID + "/live_notifications"
        });
    }, 3000); 
});
</code></pre>

<p>4) Once this Ajax request hits the controller (which is set up to handle a JavaScript response in the <code>respond_to</code> block), Rails by default will look for <code>app/views/users/live_notifications.js.erb</code> and execute the following to refresh the partial:</p>

<pre><code class="javascript app/views/users/live_notifications.js.erb">$("#live-notifications").html('&lt;%= j render "live_notifications", user: @user %&gt;');
</code></pre>

<p>This is all it took to refresh that single div every 3 seconds. However, it was far from ideal:</p>

<ul>
<li><p>Lots of refreshing for no reason (like when you&rsquo;re looking at another user&rsquo;s page and no notifications are displayed, or when nothing has changed)</p></li>
<li><p>Things that never would change are part of the div that is being refreshed (like header text, for example)</p></li>
<li><p>Last but not least, this kind of indescriminate refreshing breaks the functionality of forms&hellip;</p></li>
</ul>


<p><img class="center" src="/images/form-refreshing-problems.gif" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<h2>A Quick Fix for Form Problems</h2>

<p>Thanks to jQuery pseudo selectors, we can stop the Ajax call from being made if an input field is currently focused:</p>

<pre><code class="javascript app/assets/javascripts/live_notifications.js">$(document).ready(function() {
    ...

    setInterval(function() {
        // prevent the Ajax call from being made if the input field in the live notifications div is focused
        if (!$('#transaction_due_date').is(":focus")){
            $.ajax({
                ...
            });
        }
    }, 3000); 
});
</code></pre>

<h2>Getting More Specific</h2>

<p>The next logical step up from the &ldquo;refresh everything all the time&rdquo; strategy was to refresh the live notifications div only when looking at one&rsquo;s own show page (in other words, when the user id in the url matches the id of the current user stored in the session).</p>

<p>In order to make the <code>current_user</code> from the Rails backend available to JavaScript, I put the following in my application layout:</p>

<p>&#8220;`html app/views/layouts/application.html.erb</p>

<script type="text/javascript">
  window.currentUser = {
      id : "<%= current_user.id if current_user %>"
  }
</script>


<pre><code>
With `current_user.id` stored in an object attached to the window, making sure the Ajax call only gets made when a user is looking at his/her own profile page is simple:
</code></pre>

<p>$(document).ready(function() {
    var currentUrl = window.location.href;
    var userID = currentUrl.substr(currentUrl.lastIndexOf(&lsquo;/&rsquo;) + 1);</p>

<pre><code>if (currentUrl.endsWith('/users/' + window.currentUser.id)) {
    setInterval(function() {
        ...
    }, 3000); 
}
</code></pre>

<p>});
&#8220;`</p>

<h2>The Final Refactor: Only Refresh When things Have Changed</h2>

<p>To change only things that have changed, when they have changed, the ability to compare what&rsquo;s on the back end with what&rsquo;s on the front end is needed.</p>

<p>For this part, I needed to capture the state of all of a user&rsquo;s transactions and friendships (the two things for which there may be a notification), and hide this information on the page. I created a method in the <code>User</code> model that returns all of these states in an array, and put this into a hidden element on the page:</p>

<p><img class="center" src="/images/hidden-tracker.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Since the transactions could also have due dates, I did something similar for those.</p>

<p>The next step was to change the code in <code>app/views/users/live_notifications.js.erb</code> to check the current state of the user&rsquo;s transactions and friendships and see if the <code>#all-categories-tracker</code> is up to date:</p>

<pre><code class="javascript app/views/users/live_notifications.js.erb">var previousInteractionStates = $('#all-categories-tracker').text();
var currentInteractionStates = "&lt;%= @user.transactions_and_friendships_data_array %&gt;";

var countOrStatusChanged = previousInteractionStates !== currentInteractionStates;

var previousDueDates = $.map($(".due-date"), function(val) {
  return $(val).text()
});
var currentDueDates = "&lt;%= @user.due_date_list %&gt;";

var dueDatesChanged = currentDueDates !== previousDueDates.toString();

if (countOrStatusChanged || dueDatesChanged) {
    // UPDATE THE "MASTER TRACKER"
    $('#all-categories-tracker').html(currentInteractionStates);

    // CHECK EACH INDIVIDUAL CATEGORY AND CHANGE ONLY WHAT’S NEEDED
    &lt;% notification_categories.each do |category| %&gt;
        var currentCategory = "&lt;%= category %&gt;";

        // DEAL WITH ANY CHANGES IN COUNT OR STATE
        var currentCategoryStates  = "&lt;%= @user.states(category) %&gt;";
        var previousCategoryStates = $(".category-tracker#" + currentCategory).html();

        // if there's been a change for this category
        if (currentCategoryStates !== previousCategoryStates) {
            // Update the DOM accordingly
             …
        }

        // DEAL WITH CHANGED DUE DATES FOR TRANSACTIONS
        if (currentCategory === 'active_requested_transactions' &amp;&amp; dueDatesChanged) {
            // Update the DOM accordingly
              …
        }        
    &lt;% end %&gt;
}
</code></pre>

<p>With this final refactoring, checks are in place that stop the unnecessary refreshing that came with the first version:</p>

<p><img class="center" src="/images/live-notifications-flow.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<h2>Alternatives</h2>

<p>The method I described above for achieving live notifications is very basic Ajax polling. Every serveral seconds, a request/response cycle fires. This inevitably means lots of database querying, even if the amount of refreshing can be reduced to a minimum. In my search for ways to reduce the burden this puts on the database, here are some other techniques I&rsquo;ve found that may offer some advantages:</p>

<p>1) Long Polling</p>

<p>With this technique, a request fires and waits for a change before sending a response. Then another request can be fired.</p>

<p>2) Web Sockets</p>

<p>Very different than Ajax polling or long polling, web sockets are used for continuous communication between server and client.</p>

<p>3) Server-Sent Events</p>

<p>Unlike web sockets which allows for continuous back and forth from server to client, this technique establishes a persistent connection that allows the server to send data to the client, but not the other way around.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript: The Honey Badger of Programming Languages]]></title>
    <link href="http://roseweixel.github.io/blog/2014/11/15/javascript-the-honey-badger-of-programming-languages/"/>
    <updated>2014-11-15T17:49:20-05:00</updated>
    <id>http://roseweixel.github.io/blog/2014/11/15/javascript-the-honey-badger-of-programming-languages</id>
    <content type="html"><![CDATA[<p>After spending six weeks in Ruby land, last week was all JavaScript all the time at <a href="http://www.flatironschool.com">The Flatiron School</a>. I feel like I&rsquo;ve just added a hammer with superpowers to my programming tool box. You might bend a few nails along the way, but you can build almost anything with it.</p>

<p>Also, JavaScript is weird. Although it cares a lot about semi-colons, there are some important ways in which, just like the honey badger, it just doesn&rsquo;t seem to care at all. Here I will attempt to get comfortable with this strange new animal by diving deep into some of its more surprising aspects. To provide some contrast and context, especially for those who (like myself) are more at home with Ruby, I&rsquo;ll make some comparisons as I go along.</p>

<h2>Scope</h2>

<p>Let&rsquo;s dive right in. For comparison, here is some Ruby:</p>

<pre><code class="ruby javascript-ruby-comparison/ruby.rb">dog = 'Fido'

def bark
  puts "#{dog} says woof"
end

bark
</code></pre>

<p>In Ruby, a method is a scope gate, so <code>dog</code> is not defined in the <code>bark</code> method. Ruby will tell you this in no uncertain terms:</p>

<pre><code class="console">[18:12:24] javascript-ruby-comparison
♥ ruby ruby.rb
ruby.rb:4:in `bark': undefined local variable or method `dog' for main:Object (NameError)
    from ruby.rb:7:in `&lt;main&gt;'
</code></pre>

<p>On line 4, Ruby has no idea about what <code>dog</code> is, because the universe in line 4 is the local scope of the method <code>bark</code>. This scope gate can be very nice, since it means we cannot accidentally overwrite a variable we defined in the global scope from within a method. In order to make <code>dog</code> into a global variable that we can access inside the method, Ruby requires us to be very explicit about it, putting a <code>$</code> in front of that variable both where it is defined and wherever it is referenced:</p>

<pre><code class="ruby javascript-ruby-comparison/ruby.rb">$dog = 'Fido'

def bark
  puts "#{$dog} says woof"
end

bark
</code></pre>

<p>Now we clearly see that we are playing with a global variable, and Ruby plays along:</p>

<pre><code class="console">[18:32:01] javascript-ruby-comparison
♥ ruby ruby.rb
Fido says woof
</code></pre>

<p>While JavaScript does have a concept of functions creating a new scope, variables assigned outside of those functions can easily be accessed from within:</p>

<pre><code class="javascript javascript-ruby-comparison/javascript.js">var dog = 'Fido'

function bark(){
  console.log(dog + ' says woof');
}

bark();
</code></pre>

<p>JavaScript doesn&rsquo;t care if you want to reach outside the function&rsquo;s scope to grab a variable. JavaScript functions have knowledge of the universe around them:
<code>console
[18:38:34] javascript-ruby-comparison
♥ jsc javascript.js
--&gt; Fido says woof
</code></p>

<p>So what else can you do with a variable defined outside a function from within a function? As it turns out, JavaScript will let you do whatever you want:</p>

<pre><code class="javascript javascript-ruby-comparison/javascript.js">var dog = 'Fido'

function bark(){
  dog = 'Spot'
  debug(dog + ' says woof from within the function');
}

debug(dog + ' says woof outside of the function');
bark();
debug(dog + ' says woof after the function is called');
</code></pre>

<p>What happened to Fido?</p>

<pre><code class="console">[20:47:14] javascript-ruby-comparison
♥ jsc javascript.js 
--&gt; Fido says woof outside of the function
--&gt; Spot says woof from within the function
--&gt; Spot says woof after the function is called
</code></pre>

<p>Looks like the name change was permanent. And by the way, by always using <code>var</code>, we can prevent such dangers:</p>

<pre><code class="javascript javascript-ruby-comparison/javascript.js">var dog = 'Fido'

function bark(){
  var dog = 'Spot'
  debug(dog + ' says woof from within the function');
}

debug(dog + ' says woof outside of the function');
bark();
debug(dog + ' says woof after the function is called');
</code></pre>

<pre><code class="console">♥ jsc javascript.js 
--&gt; Fido says woof outside of the function
--&gt; Spot says woof from within the function
--&gt; Fido says woof after the function is called
</code></pre>

<p>By using <code>var</code> within the function, we created an entirely different <code>dog</code> and did not alter the original.</p>

<h2>Arity Schmarity</h2>

<p>Before we go any further, I must admit that hadn&rsquo;t heard the word arity until I crossed paths with JavaScript. I reckon I&rsquo;m not alone in this, so here&rsquo;s a definition courtesy of <a href="http://en.wikipedia.org/wiki/Arity">Wikipedia</a>:</p>

<blockquote><p>In logic, mathematics, and computer science, the <strong>arity</strong> of a function or operation is the number of arguments or operands the function or operation accepts.</p></blockquote>

<p>OK. This sounds like something I know from Ruby land. Here&rsquo;s a familiar example:</p>

<pre><code class="ruby javascript-ruby-comparison/ruby.rb">class Dog
  def initialize(name)
    @name = name
  end

end
</code></pre>

<p>According to the above definition, the <code>initialize</code> method of the <code>Dog</code> class takes exactly one argument. You could say its arity is one (more commonly, this is known as a unary function).</p>

<p>Ruby cares about arity, and will give you very nice error messages to make you aware of this:</p>

<pre><code class="console">2.1.2 :002 &gt; require 'ruby.rb'
 =&gt; true 
2.1.2 :003 &gt; fido = Dog.new
ArgumentError: wrong number of arguments (0 for 1)
    from /Users/rose/Development/code/javascript-ruby-comparison/ruby.rb:3:in `initialize'
    from (irb):3:in `new'
    from (irb):3
    from /Users/rose/.rvm/rubies/ruby-2.1.2/bin/irb:11:in `&lt;main&gt;'
</code></pre>

<p>I tried to make a new <code>Dog</code> with 0 arguments, and Ruby was expecting 1. So Ruby blew up. This is arity checking at work.</p>

<p>JavaScript does not care about arity! Here&rsquo;s photographic proof (this is a lot easier to see in the browser&rsquo;s JavaScript console):</p>

<p><img class="center" src="/images/js-no-arity-checking.png" width="700" height="700" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>To review what just happened:</p>

<ul>
<li>I made a constructor function for <code>Dog</code> (yeah, functions are really all-purpose in JavaScript, so that right there was a class definition of sorts).</li>
<li>In this constructor function, I said that <code>Dog</code> takes a <code>name</code>.</li>
<li>I made a new <code>Dog</code>, <code>fido</code>, and did not pass in any arguments.</li>
<li>JavaScript did not blow up.</li>
<li>Just to be sure, I asked JavaScript to show me <code>fido</code>.</li>
<li>JavaScript returned a <code>Dog</code> object with a <code>name</code> of <code>undefined</code>.</li>
</ul>


<p>Whenever it can, JavaScript will try to help you out, whether you want it to or not. If you say a <code>Dog</code> has a <code>name</code> and then forget to give it one, JavaScript will trust that this was your intent and will throw in an <code>undefined</code> rather than yelling at you.</p>

<h2>Teaching Old Dogs New Tricks</h2>

<p>Ruby cares about defining an object&rsquo;s attributes and behaviors up front. Objects in Ruby behave in consistent and predicatable ways.</p>

<p>Using our prior definition of the <code>Dog</code> class, Ruby will let us know that we haven&rsquo;t taught <code>Dog</code>s to bark yet:</p>

<pre><code class="console">2.1.2 :001 &gt; require 'ruby.rb'
 =&gt; true 
2.1.2 :002 &gt; fido = Dog.new('Fido')
 =&gt; #&lt;Dog:0x007f9fd5757c78 @name="Fido"&gt; 
2.1.2 :003 &gt; fido.bark
NoMethodError: undefined method `bark' for #&lt;Dog:0x007f9fd5757c78 @name="Fido"&gt;
    from (irb):3
    from /Users/rose/.rvm/rubies/ruby-2.1.2/bin/irb:11:in `&lt;main&gt;'
</code></pre>

<p>Of course! We did not define a <code>bark</code> method, so we get a predictable <code>NoMethodError</code>.</p>

<p>JavaScript doesn&rsquo;t care about defining all of an object&rsquo;s attributes and behaviors up front, and pretty much lets you do whatever you want, whenever you want. Here&rsquo;s a continuation of the console session above:</p>

<p><img class="center" src="/images/js-fido-barks.png" width="700" height="700" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<ul>
<li>I asked <code>fido</code> to bark, having never defined a <code>bark</code> function or attribute. JavaScript quietly returned <code>undefined</code>.</li>
<li>I told JavaScript to give <code>fido.bark</code> the value of <code>'woof'</code>, and JavaScript happily obliged.</li>
<li>Now not only can <code>fido</code> bark, but the <code>Dog</code> object that is <code>fido</code> has been fundamentally altered, now containing a new <code>bark</code> attribute!</li>
</ul>


<p>So, can all <code>Dog</code>s bark now?</p>

<p><img class="center" src="/images/js-spot-cant-bark.png" width="700" height="700" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>No, they cannot. Now the definition of <code>Dog</code> is a bit of a mess - <code>fido</code> is a <code>Dog</code> that can bark, while <code>spot</code> can&rsquo;t. The very nature of <code>Dog</code>-ness has been brought into question, and JavaScript is fine with all of this. No errors, no complaining. For better or for worse.</p>

<h2>Playing with Global Scope</h2>

<p>This one is extra weird, so get ready.</p>

<p>In the hierarchy of Ruby objects, <code>main</code> is the top level:</p>

<pre><code class="console">♥ irb
2.1.2 :001 &gt; self
 =&gt; main 
2.1.2 :002 &gt; self.class
 =&gt; Object 
2.1.2 :003 &gt; 
</code></pre>

<p>I don&rsquo;t know why you&rsquo;d want to mess with <code>main</code>, and Ruby makes certain it&rsquo;s not easy to do so (in fact, it&rsquo;s impossible to do so by accident):</p>

<pre><code class="console">2.1.2 :003 &gt; self.name
NoMethodError: undefined method `name' for main:Object
    from (irb):3
    from /Users/rose/.rvm/rubies/ruby-2.1.2/bin/irb:11:in `&lt;main&gt;'
2.1.2 :004 &gt; self.name = "Rose"
NoMethodError: undefined method `name=' for main:Object
    from (irb):4
    from /Users/rose/.rvm/rubies/ruby-2.1.2/bin/irb:11:in `&lt;main&gt;'
2.1.2 :005 &gt; 
</code></pre>

<p>Want to mess with the top-level object in JavaScript? Go right ahead, JavaScript doesn&rsquo;t care!</p>

<pre><code class="console">&gt;&gt;&gt; this.name
undefined
&gt;&gt;&gt; this.name = "Rose"
Rose
&gt;&gt;&gt; this
[object global]
&gt;&gt;&gt; this.name
Rose
&gt;&gt;&gt; 
</code></pre>

<p>I just named the global object after myself, and JavaScript did not care one bit. This example is a bit contrived, but believe me that some undesireable things can happen if you don&rsquo;t watch out for global assignment. Here&rsquo;s a (slightly) less contrived example:</p>

<pre><code class="javascript javascript-ruby-comparison/javascript.js">function Dog(name){
    this.name = name;
    this.hunger = true;
    this.bowl = 'full';
}

Dog.prototype.checkNeeds = function() {
    if(this.hunger === true){
        (function feed(){
            this.hunger = false;
            this.bowl = 'empty';
        })();
    } else {
        (function play(){
            this.hunger = true;
        })();
    }
};

var fido = new Dog('Fido');

debug(fido.hunger);

fido.checkNeeds();

debug(fido.hunger);
debug(this.hunger);
debug(this);
</code></pre>

<p>If I run this code, here&rsquo;s what my <code>debug</code> statements reveal:</p>

<pre><code class="console">♥ jsc javascript.js 
--&gt; true            // fido was born hungry
--&gt; true            // after calling checkNeeds(), he's still hungry...
--&gt; false           // ...but this isn't hungry...
--&gt; [object global] // because we fed the global object instead of fido!
</code></pre>

<p>As you can see, Bad Things can happen when the global object is always available. Fortunately, there is a way for you to make JavaScript care about this! You just have to tell JavaScript to <code>use strict</code>.</p>

<pre><code class="javascript javascript-ruby-comparison/javascript.js">'use strict';

function Dog(name){
    // the rest of my code...
</code></pre>

<p>Now, when we run the code, JavaScript will blow up just the way we want it to!</p>

<pre><code class="console">♥ jsc javascript.js 
--&gt; true
Exception: TypeError: Attempted to assign to readonly property.
feed@javascript.js:12:17
checkNeeds@javascript.js:14:11
global code@javascript.js:24:16
</code></pre>

<h2>The Moral of the Story</h2>

<p>This was a long post, and it probably could get longer. But I think this is enough to chew on for now. The bottom line is that JavaScript has some crazy ways, but these ways are not unlearnable, and the reward for learning them is a much saner coding experience. If you understand the quirks, remember your <code>var</code>s, and always <code>use strict</code>, you and JavaScript can be unstoppable, just like the honey badger.</p>

<p><img class="center" src="/images/nothing-stops-honey-badger.png" width="500" height="500" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>
]]></content>
  </entry>
  
</feed>
